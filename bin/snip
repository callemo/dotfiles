#!/usr/bin/env python3
"""Expand text snippets."""
import argparse
import datetime
import re
import sys

# Dictionary of snippets
SNIPPETS = {}


def main():
    parser = argparse.ArgumentParser(description="Expand text snippets.")
    parser.add_argument("-t", "--tab", default="\t", help="indent string")
    parser.add_argument(
        "-l", "--list", action="store_true", help="list available snippets"
    )
    parser.add_argument("snippet", nargs="?", help="name of the snippet to expand")
    parser.add_argument("args", nargs="*", help="arguments to pass to the snippet")

    args = parser.parse_args()

    # List snippets or show help if no snippet provided
    if args.list or not args.snippet:
        print_snippet_list()
        return

    # Get and call the snippet function
    snippet_func = SNIPPETS.get(args.snippet)
    if not snippet_func:
        print(f"Unknown snippet: {args.snippet}", file=sys.stderr)
        print_snippet_list()
        return 1

    # Expand the snippet and print it
    code = expand_snippet(snippet_func, args.args, args.tab)
    print(code)


def print_snippet_list():
    """Print all available snippets with their descriptions."""
    if not SNIPPETS:
        return

    print("\nAvailable snippets:")

    # Find the longest snippet name for formatting
    max_name_len = max(len(name) for name in SNIPPETS)
    fmt = f"  %-{max_name_len}s - %s"

    # Print snippets in a table-like format
    for name, func in sorted(SNIPPETS.items()):
        doc = func.__doc__ or ""
        print(fmt % (name, doc))


def expand_snippet(func, args=None, tab="\t"):
    """Expand a snippet using the given function and arguments."""
    if args is None:
        args = []

    builder = IndentBuilder(tab)
    result = func(builder, args)
    return result if result is not None else builder.text()


class IndentBuilder:
    """Generates indented code."""

    def __init__(self, tab="\t"):
        self.tab = tab
        self.level = 0
        self.lines = []

    def write(self, line):
        """Add a line with proper indentation."""
        self.lines.append(self.tab * self.level + line)
        return self

    def indent(self):
        """Increase indentation level."""
        self.level += 1
        return self

    def dedent(self):
        """Decrease indentation level."""
        if self.level < 1:
            raise IndentationError(
                f"Cannot dedent past level 0 at line {len(self.lines)}"
            )
        self.level -= 1
        return self

    def text(self):
        """Return the complete text."""
        return "\n".join(self.lines)


# Snippet implementations


def _expand_shlog(builder, args):
    """Shell logging."""
    builder.write('prefix="${0##*/}:"')
    builder.write('log() { echo "$prefix" "$@" >&2; }')
    builder.write('fatal() { log "$@"; exit 1; }')


def _expand_shopts(builder, args):
    """Shell getopts. [optstring] - Generate getopt parsing for shell scripts."""
    optstring = args[0] if args else ":abc:"
    if optstring[0] != ":":
        optstring = ":" + optstring

    builder.write("usage() { sed -En '2,/^[^#]/ s/^# //p' \"$0\" >&2; }")
    builder.write("")
    builder.write(f"while getopts {optstring} f")
    builder.write("do")
    builder.indent()
    builder.write("case $f in")

    last = len(optstring) - 1
    for i, v in enumerate(optstring):
        if v == ":":
            continue
        if i < last and optstring[i + 1] == ":":
            builder.write(f"{v})  {v}arg=$OPTARG;;")
        else:
            builder.write(f"{v})  {v}flag=$f;;")

    builder.write("\\?) usage; exit 2;;")
    builder.write("esac")
    builder.dedent()
    builder.write("done")
    builder.write("shift $((OPTIND - 1))")


def _expand_shdir(builder, args):
    """Shell program directory."""
    builder.write('progdir="$(cd "${0%/*}" && pwd -P)"')


def _expand_shcase(builder, args):
    """Shell case. [case1 case2...] - Generate shell case statement with cases."""
    # Default cases if none provided
    cases = args if args else ["option1", "option2", "option3"]

    builder.write("case $1 in")
    builder.indent()

    for arg in cases:
        builder.write(f"{arg}) {arg};;")

    builder.write("* ) usage; exit 2;;")
    builder.dedent()
    builder.write("esac")


def _expand_pyargs(builder, args):
    """Python argparse. [optstring] - Generate argument parser from option string."""
    optstring = args[0] if args else "abc:"

    builder.write("parser = argparse.ArgumentParser()")

    last = len(optstring) - 1
    for i, v in enumerate(optstring):
        if v == ":":
            continue
        if i < last and optstring[i + 1] == ":":
            builder.write(
                f'parser.add_argument("-{v}", help="{v} option that requires an argument")'
            )
        else:
            builder.write(
                f'parser.add_argument("-{v}", action="store_true", help="Enable {v} option")'
            )

    builder.write("args = parser.parse_args()")


def _expand_pyfilter(builder, args):
    """Python command line filter."""
    builder.write("#!/usr/bin/env python3")
    builder.write('"""Command line filter."""')
    builder.write("import argparse")
    builder.write("import fileinput")
    builder.write("import os")
    builder.write("import sys")
    builder.write("")
    builder.write("def main():")
    builder.indent()
    builder.write("parser = argparse.ArgumentParser()")
    builder.write('parser.add_argument("files", nargs="*")')
    builder.write("args = parser.parse_args()")
    builder.write("with fileinput.input(files=args.files) as f:")
    builder.indent()
    builder.write("for line in f:")
    builder.indent()
    builder.write('print(line, end="")')
    builder.dedent()
    builder.dedent()
    builder.dedent()
    builder.write("")
    builder.write("try:")
    builder.indent()
    builder.write("main()")
    builder.write("sys.stdout.flush()")
    builder.dedent()
    builder.write("except (BrokenPipeError, KeyboardInterrupt):")
    builder.indent()
    builder.write("os.dup2(os.open(os.devnull, os.O_WRONLY), sys.stdout.fileno())")
    builder.dedent()


def _expand_pydir(builder, args):
    """Python program directory."""
    builder.write("progdir = os.path.realpath(os.path.dirname(__file__))")


def _expand_nfile(builder, args):
    """Note file name."""
    note_id = datetime.datetime.today().strftime("%Y%m%d%H%M")
    title = "_".join(args)
    title = re.sub("[^A-Za-z_-]", "", title)
    return note_id + "-" + title.lower() + ".txt"


def _expand_nmeta(builder, args):
    """Note metadata. [title] [key:value pairs] - Define metadata like date, tags, etc."""
    # Default values
    metadata = {
        "Date": datetime.datetime.today().isoformat(timespec="seconds"),
        "Title": "",
        "Tags": "",
        "References": "",
        "ISBN": "",
        "URL": "",
        "Author": "",
        "Year": "",
        "Month": "",
    }

    # First positional argument is title if not prefixed
    if args and ":" not in args[0]:
        metadata["Title"] = args[0]
        args = args[1:]

    # Process named arguments (key:value format)
    for arg in args:
        if ":" in arg:
            key, value = arg.split(":", 1)
            key = key.capitalize()
            if key in metadata:
                metadata[key] = value

    # Write metadata section
    builder.write("---")
    for key, value in metadata.items():
        builder.write(f"{key}: {value}")
    builder.write("---")
    builder.write("")

    # Add title as heading if provided
    if metadata["Title"]:
        builder.write("# " + metadata["Title"])
        builder.write("")


def _expand_awkbasic(builder, args):
    """AWK basic program structure."""
    builder.write("#!/usr/bin/awk -f")
    builder.write("")
    builder.write("BEGIN {")
    builder.indent()
    builder.write("# setup")
    builder.dedent()
    builder.write("}")
    builder.write("")
    builder.write("/pattern/ {")
    builder.indent()
    builder.write("# action")
    builder.dedent()
    builder.write("}")
    builder.write("")
    builder.write("END {")
    builder.indent()
    builder.write("# summary")
    builder.dedent()
    builder.write("}")


def _expand_awkfields(builder, args):
    """AWK field processing examples."""
    builder.write("# Field variables")
    builder.write("# $0  - entire line")
    builder.write("# $1  - first field")
    builder.write("# NF  - number of fields")
    builder.write("# NR  - record number")
    builder.write("# FS  - field separator (default: whitespace)")
    builder.write("# OFS - output field separator (default: space)")
    builder.write("")
    builder.write("# Print specific fields")
    builder.write("{ print $1, $3 }")
    builder.write("")
    builder.write("# Process all fields")
    builder.write("{ ")
    builder.indent()
    builder.write("for (i = 1; i <= NF; i++)")
    builder.indent()
    builder.write("sum += $i")
    builder.dedent()
    builder.dedent()
    builder.write("}")


def _expand_awkfunc(builder, args):
    """AWK built-in functions."""
    builder.write("# String functions")
    builder.write("# length(s)   - length of s")
    builder.write("# index(s, t) - position of t in s, or 0")
    builder.write("# match(s, r) - position of regex r in s or 0")
    builder.write("# split(s, a, fs) - split s into array a using fs")
    builder.write("# sub(r, s)   - substitute s for first match of r")
    builder.write("# gsub(r, s)  - substitute s for all matches of r")
    builder.write("# substr(s, p, n) - n-char substring of s from p")
    builder.write("")
    builder.write("# Examples")
    builder.write("{ ")
    builder.indent()
    builder.write("# character count")
    builder.write("n = length($1)")
    builder.write("")
    builder.write("# uppercase (non-standard, use loop instead)")
    builder.write("# Standard way to uppercase:")
    builder.write('up = ""')
    builder.write("for (i = 1; i <= length($1); i++) {")
    builder.indent()
    builder.write("c = substr($1, i, 1)")
    builder.write('if (c >= "a" && c <= "z")')
    builder.indent()
    builder.write('c = sprintf("%c", ord(c) - 32)')
    builder.dedent()
    builder.write("up = up c")
    builder.dedent()
    builder.write("}")
    builder.write("")
    builder.write("# replace text")
    builder.write('gsub(/old/, "new")')
    builder.dedent()
    builder.write("}")


def _expand_awkarray(builder, args):
    """AWK array operations."""
    builder.write("BEGIN {")
    builder.indent()
    builder.write("# associative arrays")
    builder.write('count["red"] = 5')
    builder.write('count["blue"] = 7')
    builder.write("")
    builder.write("# iterate over array")
    builder.write("for (c in count)")
    builder.indent()
    builder.write("print c, count[c]")
    builder.dedent()
    builder.write("")
    builder.write("# check if key exists")
    builder.write('if ("red" in count)')
    builder.indent()
    builder.write('print "found red:", count["red"]')
    builder.dedent()
    builder.write("")
    builder.write("# delete element")
    builder.write('delete count["red"]')
    builder.write("")
    builder.write("# multi-dimensional arrays")
    builder.write('items["fruit", "apple"] = 5')
    builder.write('items["veg", "carrot"] = 10')
    builder.dedent()
    builder.write("}")


def _expand_awkcsv(builder, args):
    """AWK CSV file processing."""
    builder.write('BEGIN { FS = ","; hdr = 0 }')
    builder.write("")
    builder.write("# process header")
    builder.write("NR == 1 {")
    builder.indent()
    builder.write("for (i = 1; i <= NF; i++)")
    builder.indent()
    builder.write("col[i] = $i")
    builder.dedent()
    builder.write("hdr = 1")
    builder.write("next")
    builder.dedent()
    builder.write("}")
    builder.write("")
    builder.write("# process data rows")
    builder.write("{")
    builder.indent()
    builder.write("for (i = 1; i <= NF; i++)")
    builder.indent()
    builder.write("row[col[i]] = $i")
    builder.dedent()
    builder.write("")
    builder.write("# use column by name")
    builder.write('print row["price"] * row["quantity"]')
    builder.dedent()
    builder.write("}")


def _expand_awkgroup(builder, args):
    """AWK grouping and summarizing data."""
    builder.write("# Group and sum by first field")
    builder.write("{")
    builder.indent()
    builder.write("sum[$1] += $2")
    builder.write("cnt[$1]++")
    builder.dedent()
    builder.write("}")
    builder.write("")
    builder.write("END {")
    builder.indent()
    builder.write("for (grp in sum) {")
    builder.indent()
    builder.write('printf("%s: %d items, sum = %.2f, avg = %.2f\\n",')
    builder.indent()
    builder.write("grp, cnt[grp], sum[grp], sum[grp]/cnt[grp])")
    builder.dedent()
    builder.dedent()
    builder.write("}")
    builder.dedent()
    builder.write("}")


def _expand_awkformat(builder, args):
    """AWK formatting output."""
    builder.write("# printf formats")
    builder.write("# %d - decimal integer")
    builder.write("# %s - string")
    builder.write("# %f - floating point")
    builder.write("# %.2f - float with 2 decimals")
    builder.write("# %10s - right-justify in 10 chars")
    builder.write("# %-10s - left-justify in 10 chars")
    builder.write("")
    builder.write("# table-like output")
    builder.write("BEGIN {")
    builder.indent()
    builder.write('printf("%-10s %6s %8s\\n", "Item", "Count", "Price")')
    builder.write('printf("%-10s %6s %8s\\n", "----", "-----", "-----")')
    builder.dedent()
    builder.write("}")
    builder.write("")
    builder.write("{")
    builder.indent()
    builder.write('printf("%-10s %6d %8.2f\\n", $1, $2, $3)')
    builder.dedent()
    builder.write("}")


def _expand_awkmath(builder, args):
    """AWK math operations."""
    builder.write("# arithmetic operators: + - * / % ^")
    builder.write("# math functions (standard)")
    builder.write("# sqrt(x)   - square root")
    builder.write("# int(x)    - integer part of x")
    builder.write("# rand()    - random number between 0 and 1")
    builder.write("# srand(x)  - set seed for rand()")
    builder.write("")
    builder.write("# basic stats example")
    builder.write("{")
    builder.indent()
    builder.write("sum += $1")
    builder.write("sumsq += $1 * $1")
    builder.write("n++")
    builder.dedent()
    builder.write("}")
    builder.write("")
    builder.write("END {")
    builder.indent()
    builder.write("if (n > 0) {")
    builder.indent()
    builder.write("mean = sum / n")
    builder.write("var = sumsq / n - mean * mean")
    builder.write("stddev = sqrt(var)")
    builder.write('print "mean =", mean, "std dev =", stddev')
    builder.dedent()
    builder.write("}")
    builder.dedent()
    builder.write("}")


def _expand_awkregex(builder, args):
    """AWK regex patterns."""
    builder.write("# regex operators")
    builder.write("# /pattern/  - match pattern")
    builder.write("# ~ /pattern/ - match pattern")
    builder.write("# !~ /pattern/ - not match pattern")
    builder.write("")
    builder.write("# regex examples")
    builder.write('/^[0-9]+$/ { print $0 " is a number" }')
    builder.write("")
    builder.write('$1 ~ /^[A-Z][a-z]+$/ { print $1 " starts with capital" }')
    builder.write("")
    builder.write("# extract with regex (basic matching)")
    builder.write("{")
    builder.indent()
    builder.write("if (match($0, /[0-9]+-[0-9]+/)) {")
    builder.indent()
    builder.write("matched = substr($0, RSTART, RLENGTH)")
    builder.write("# Split manually since we can't rely on capture groups")
    builder.write("n = split(matched, parts, /-/)")
    builder.write("if (n == 2)")
    builder.indent()
    builder.write('print "range from", parts[1], "to", parts[2]')
    builder.dedent()
    builder.dedent()
    builder.write("}")
    builder.dedent()
    builder.write("}")
    builder.write("")
    builder.write("# scan a string for multiple matches")
    builder.write("{")
    builder.indent()
    builder.write("# find all numbers in a string")
    builder.write('s = "There are 42 apples and 17 oranges"')
    builder.write("pos = 1")
    builder.write("while (pos <= length(s)) {")
    builder.indent()
    builder.write("# look for next digit sequence starting from pos")
    builder.write("if (match(substr(s, pos), /[0-9]+/)) {")
    builder.indent()
    builder.write("# found a match, get its actual position in original string")
    builder.write("matchpos = pos + RSTART - 1")
    builder.write("number = substr(s, matchpos, RLENGTH)")
    builder.write('print "Found number:", number, "at position", matchpos')
    builder.write("# move past this match for next iteration")
    builder.write("pos = matchpos + RLENGTH")
    builder.dedent()
    builder.write("} else {")
    builder.indent()
    builder.write("# no more matches")
    builder.write("break")
    builder.dedent()
    builder.write("}")
    builder.dedent()
    builder.write("}")
    builder.dedent()
    builder.write("}")


def _expand_awkfile(builder, args):
    """AWK file operations."""
    builder.write("# read from multiple input files")
    builder.write("# awk 'program' file1 file2")
    builder.write("")
    builder.write("# knowing which file is being processed")
    builder.write('FILENAME == "data.txt" { print "In data.txt:", $0 }')
    builder.write("")
    builder.write("# write to file")
    builder.write("{")
    builder.indent()
    builder.write('print $1 > "results.txt"   # overwrites file')
    builder.write('print $2 >> "append.txt"   # appends to file')
    builder.write('print $3 | "sort"          # pipe to command')
    builder.dedent()
    builder.write("}")
    builder.write("")
    builder.write("# close file explicitly (good practice)")
    builder.write("END {")
    builder.indent()
    builder.write('close("results.txt")')
    builder.write('close("append.txt")')
    builder.write('close("sort")')
    builder.dedent()
    builder.write("}")


def _expand_awksys(builder, args):
    """AWK system commands."""
    builder.write("# run system command")
    builder.write("BEGIN {")
    builder.indent()
    builder.write("# execute command (portable)")
    builder.write('system("ls -l")')
    builder.dedent()
    builder.write("}")
    builder.write("")
    builder.write("# read command output (portable)")
    builder.write("{")
    builder.indent()
    builder.write('cmd = "grep " $1 " /etc/passwd"')
    builder.write("while ((cmd | getline) > 0)")
    builder.indent()
    builder.write("print $0")
    builder.dedent()
    builder.write("close(cmd)")
    builder.dedent()
    builder.write("}")


def _expand_gobasic(builder, args):
    """Go basic program structure."""
    builder.write("package main")
    builder.write("")
    builder.write("import (")
    builder.indent()
    builder.write('"fmt"')
    builder.dedent()
    builder.write(")")
    builder.write("")
    builder.write("func main() {")
    builder.indent()
    builder.write('fmt.Println("Hello, world")')
    builder.dedent()
    builder.write("}")


def _expand_goerr(builder, args):
    """Go error handling pattern."""
    builder.write("// Handle errors immediately")
    builder.write("func process() error {")
    builder.indent()
    builder.write("f, err := os.Open(filename)")
    builder.write("if err != nil {")
    builder.indent()
    builder.write("return err")
    builder.dedent()
    builder.write("}")
    builder.write("defer f.Close()")
    builder.write("")
    builder.write("// Process the file")
    builder.write("return nil")
    builder.dedent()
    builder.write("}")
    builder.write("")
    builder.write("// Usage in main()")
    builder.write("if err := process(); err != nil {")
    builder.indent()
    builder.write("log.Fatal(err)")
    builder.dedent()
    builder.write("}")


def _expand_gostruct(builder, args):
    """Go struct. [Name field1 type1...] - Define struct with fields and constructor."""
    # Parse arguments
    struct_name = "User"  # Default struct name
    fields = [
        ("ID", "int"),
        ("Name", "string"),
        ("Email", "string"),
        ("Created", "time.Time"),
    ]  # Default fields

    if args:
        # First argument is struct name
        struct_name = args[0]

        # Remaining arguments are field/type pairs
        if len(args) > 1:
            # Clear default fields if any custom fields provided
            fields = []

            # Process pairs of field name and type
            for i in range(1, len(args), 2):
                if i + 1 < len(args):
                    field_name = args[i]
                    field_type = args[i + 1]
                    fields.append((field_name, field_type))

    # Write struct definition
    builder.write(f"// {struct_name} represents an entity in the system")
    builder.write(f"type {struct_name} struct {{")
    builder.indent()

    # Add fields
    for field_name, field_type in fields:
        builder.write(f"{field_name}    {field_type}")

    builder.dedent()
    builder.write("}")
    builder.write("")

    # Constructor
    builder.write(f"// New{struct_name} creates a new {struct_name}")

    # Determine constructor parameters based on fields
    # Skip ID and Created fields (common pattern for generated fields)
    constructor_fields = [
        (name, typ) for name, typ in fields if name != "ID" and name != "Created"
    ]

    param_list = ", ".join(
        [f"{name.lower()} {typ}" for name, typ in constructor_fields]
    )

    builder.write(f"func New{struct_name}({param_list}) *{struct_name} {{")
    builder.indent()
    builder.write(f"return &{struct_name}{{")
    builder.indent()

    # Add field initializers
    for field_name, _ in fields:
        if field_name == "ID":
            # Skip ID for constructor
            continue
        elif field_name == "Created":
            builder.write(f"{field_name}: time.Now(),")
        else:
            # Use parameter with same name but lowercase
            builder.write(f"{field_name}: {field_name.lower()},")

    builder.dedent()
    builder.write("}")
    builder.dedent()
    builder.write("}")


def _expand_gocli(builder, args):
    """Go command-line flags."""
    builder.write("package main")
    builder.write("")
    builder.write("import (")
    builder.indent()
    builder.write('"flag"')
    builder.write('"fmt"')
    builder.write('"os"')
    builder.dedent()
    builder.write(")")
    builder.write("")
    builder.write("func main() {")
    builder.indent()
    builder.write("// Define flags")
    builder.write('verbose := flag.Bool("v", false, "verbose output")')
    builder.write('output := flag.String("o", "output.txt", "output file")')
    builder.write('count := flag.Int("n", 1, "number of iterations")')
    builder.write("")
    builder.write("// Parse flags")
    builder.write("flag.Parse()")
    builder.write("")
    builder.write("// Get positional arguments")
    builder.write("args := flag.Args()")
    builder.write("if len(args) < 1 {")
    builder.indent()
    builder.write('fmt.Fprintf(os.Stderr, "missing required argument\\n")')
    builder.write("os.Exit(1)")
    builder.dedent()
    builder.write("}")
    builder.write("")
    builder.write("// Use the flags")
    builder.write("if *verbose {")
    builder.indent()
    builder.write('fmt.Printf("Processing %d iterations\\n", *count)')
    builder.dedent()
    builder.write("}")
    builder.dedent()
    builder.write("}")


def _expand_gojson(builder, args):
    """Go JSON marshaling and unmarshaling."""
    builder.write("package main")
    builder.write("")
    builder.write("import (")
    builder.indent()
    builder.write('"encoding/json"')
    builder.write('"fmt"')
    builder.write('"log"')
    builder.dedent()
    builder.write(")")
    builder.write("")
    builder.write("// Person represents a person with a name and age")
    builder.write("type Person struct {")
    builder.indent()
    builder.write('Name string `json:"name"`')
    builder.write('Age  int    `json:"age"`')
    builder.dedent()
    builder.write("}")
    builder.write("")
    builder.write("func main() {")
    builder.indent()
    builder.write("// Marshal: struct to JSON")
    builder.write('p := Person{Name: "Alice", Age: 30}')
    builder.write("data, err := json.Marshal(p)")
    builder.write("if err != nil {")
    builder.indent()
    builder.write("log.Fatal(err)")
    builder.dedent()
    builder.write("}")
    builder.write('fmt.Printf("JSON: %s\\n", data)')
    builder.write("")
    builder.write("// Unmarshal: JSON to struct")
    builder.write('jsonData := []byte(`{"name":"Bob","age":25}`)')
    builder.write("var person Person")
    builder.write("err = json.Unmarshal(jsonData, &person)")
    builder.write("if err != nil {")
    builder.indent()
    builder.write("log.Fatal(err)")
    builder.dedent()
    builder.write("}")
    builder.write('fmt.Printf("Person: %+v\\n", person)')
    builder.dedent()
    builder.write("}")


def _expand_gohttp(builder, args):
    """Go HTTP server."""
    builder.write("package main")
    builder.write("")
    builder.write("import (")
    builder.indent()
    builder.write('"fmt"')
    builder.write('"log"')
    builder.write('"net/http"')
    builder.dedent()
    builder.write(")")
    builder.write("")
    builder.write("func main() {")
    builder.indent()
    builder.write("// Simple handler function")
    builder.write('http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {')
    builder.indent()
    builder.write('fmt.Fprintf(w, "Hello, %s!", r.URL.Path[1:])')
    builder.dedent()
    builder.write("})")
    builder.write("")
    builder.write("// Start server")
    builder.write('log.Println("Starting server on :8080")')
    builder.write('if err := http.ListenAndServe(":8080", nil); err != nil {')
    builder.indent()
    builder.write("log.Fatal(err)")
    builder.dedent()
    builder.write("}")
    builder.dedent()
    builder.write("}")


def _expand_goch(builder, args):
    """Go concurrency with goroutines and channels."""
    builder.write("package main")
    builder.write("")
    builder.write("import (")
    builder.indent()
    builder.write('"fmt"')
    builder.write('"sync"')
    builder.dedent()
    builder.write(")")
    builder.write("")
    builder.write("func worker(id int, jobs <-chan int, results chan<- int) {")
    builder.indent()
    builder.write("for j := range jobs {")
    builder.indent()
    builder.write('fmt.Printf("worker %d processing job %d\\n", id, j)')
    builder.write("// Do work")
    builder.write("results <- j * 2")
    builder.dedent()
    builder.write("}")
    builder.dedent()
    builder.write("}")
    builder.write("")
    builder.write("func main() {")
    builder.indent()
    builder.write("numJobs := 5")
    builder.write("jobs := make(chan int, numJobs)")
    builder.write("results := make(chan int, numJobs)")
    builder.write("")
    builder.write("// Start workers")
    builder.write("for w := 1; w <= 3; w++ {")
    builder.indent()
    builder.write("go worker(w, jobs, results)")
    builder.dedent()
    builder.write("}")
    builder.write("")
    builder.write("// Send jobs")
    builder.write("for j := 1; j <= numJobs; j++ {")
    builder.indent()
    builder.write("jobs <- j")
    builder.dedent()
    builder.write("}")
    builder.write("close(jobs)")
    builder.write("")
    builder.write("// Collect results")
    builder.write("for i := 0; i < numJobs; i++ {")
    builder.indent()
    builder.write("result := <-results")
    builder.write('fmt.Printf("result: %d\\n", result)')
    builder.dedent()
    builder.write("}")
    builder.dedent()
    builder.write("}")


def _expand_gowg(builder, args):
    """Go WaitGroup for synchronization."""
    builder.write("package main")
    builder.write("")
    builder.write("import (")
    builder.indent()
    builder.write('"fmt"')
    builder.write('"sync"')
    builder.write('"time"')
    builder.dedent()
    builder.write(")")
    builder.write("")
    builder.write("func worker(id int, wg *sync.WaitGroup) {")
    builder.indent()
    builder.write("defer wg.Done()")
    builder.write('fmt.Printf("Worker %d starting\\n", id)')
    builder.write("// Simulate work")
    builder.write("time.Sleep(time.Second)")
    builder.write('fmt.Printf("Worker %d done\\n", id)')
    builder.dedent()
    builder.write("}")
    builder.write("")
    builder.write("func main() {")
    builder.indent()
    builder.write("var wg sync.WaitGroup")
    builder.write("")
    builder.write("// Launch several workers")
    builder.write("for i := 1; i <= 5; i++ {")
    builder.indent()
    builder.write("wg.Add(1)")
    builder.write("go worker(i, &wg)")
    builder.dedent()
    builder.write("}")
    builder.write("")
    builder.write("// Wait for all workers to complete")
    builder.write('fmt.Println("Waiting for workers to finish...")')
    builder.write("wg.Wait()")
    builder.write('fmt.Println("All workers completed")')
    builder.dedent()
    builder.write("}")


def _expand_gotest(builder, args):
    """Go test. [Func RetType ParamTypes...] - Create test function with tests and benchmarks."""
    # Default values
    func_name = "Add"
    return_type = "int"
    param_types = ["int", "int"]

    if args:
        # First argument is function name
        func_name = args[0]

        # Second argument is return type
        if len(args) > 1:
            return_type = args[1]

        # Remaining arguments are parameter types
        if len(args) > 2:
            param_types = args[2:]

    # Create parameter string
    param_list = []
    for i, ptype in enumerate(param_types):
        param_list.append(f"{chr(97+i)} {ptype}")
    param_str = ", ".join(param_list)

    # Function letter variables for parameters (a, b, c, etc.)
    param_vars = ", ".join([chr(97 + i) for i in range(len(param_types))])

    builder.write(f"package mypackage")
    builder.write("")
    builder.write("import (")
    builder.indent()
    builder.write('"fmt"')
    builder.write('"testing"')
    builder.dedent()
    builder.write(")")
    builder.write("")
    builder.write(f"func {func_name}({param_str}) {return_type} {{")
    builder.indent()
    if return_type == "error":
        builder.write("return nil")
    elif return_type == "string":
        builder.write('return ""')
    elif return_type == "bool":
        builder.write("return true")
    elif "int" in return_type:
        builder.write("return 0")
    elif "float" in return_type:
        builder.write("return 0.0")
    else:
        builder.write("// TODO: implement function")
        builder.write("return nil")
    builder.dedent()
    builder.write("}")
    builder.write("")

    # Helper function for test setup (optional)
    builder.write("// testSetup prepares test resources")
    builder.write("func testSetup() func() {")
    builder.indent()
    builder.write("// Initialize test resources")
    builder.write("")
    builder.write("// Return teardown function")
    builder.write("return func() {")
    builder.indent()
    builder.write("// Clean up test resources")
    builder.dedent()
    builder.write("}")
    builder.dedent()
    builder.write("}")
    builder.write("")

    # Test function with table-driven tests
    builder.write(f"func Test{func_name}(t *testing.T) {{")
    builder.indent()
    builder.write("// Setup test environment and defer cleanup")
    builder.write("teardown := testSetup()")
    builder.write("defer teardown()")
    builder.write("")

    builder.write("// Table-driven test cases")
    builder.write("tests := []struct {")
    builder.indent()
    builder.write("name     string")

    # Parameter fields
    for i, ptype in enumerate(param_types):
        builder.write(f"{chr(97+i)}        {ptype}")

    builder.write(f"expected {return_type}")
    builder.dedent()
    builder.write("}{")
    builder.indent()

    # Example test cases based on return type
    if return_type == "int":
        builder.write('{name: "simple", a: 1, b: 2, expected: 3},')
        builder.write('{name: "negative", a: -1, b: 1, expected: 0},')
    elif return_type == "string":
        builder.write(
            '{name: "simple", a: "hello", b: "world", expected: "helloworld"},'
        )
    elif return_type == "bool":
        builder.write('{name: "true case", a: true, b: true, expected: true},')
        builder.write('{name: "false case", a: true, b: false, expected: false},')
    else:
        builder.write(
            '{name: "case1", /* TODO: add test parameters */, expected: /* expected value */},'
        )

    builder.dedent()
    builder.write("}")
    builder.write("")

    builder.write("// Run subtests for each test case")
    builder.write("for _, tc := range tests {")
    builder.indent()
    builder.write("t.Run(tc.name, func(t *testing.T) {")
    builder.indent()
    builder.write(
        f"got := {func_name}(tc.{', tc.'.join([chr(97+i) for i in range(len(param_types))])})"
    )

    # Conditional check based on return type
    builder.write("if got != tc.expected {")
    builder.indent()

    # Format string for error message depends on return type
    format_str = ""
    if return_type == "string":
        format_str = "%q"
    elif return_type == "bool":
        format_str = "%v"
    elif "int" in return_type:
        format_str = "%d"
    elif "float" in return_type:
        format_str = "%f"
    else:
        format_str = "%v"

    # Build error message with appropriate formatting
    params_fmt = ", ".join([f"tc.{chr(97+i)}" for i in range(len(param_types))])
    builder.write(
        f't.Errorf("{func_name}({", ".join(["%v"]*len(param_types))}) = {format_str}; expected {format_str}", {params_fmt}, got, tc.expected)'
    )
    builder.dedent()
    builder.write("}")
    builder.dedent()
    builder.write("})")
    builder.dedent()
    builder.write("}")
    builder.dedent()
    builder.write("}")
    builder.write("")

    # Add test example
    builder.write(f"func Example{func_name}() {{")
    builder.indent()

    # Create example parameters based on type
    example_params = []
    for i, ptype in enumerate(param_types):
        if ptype == "string":
            example_params.append(f'"{chr(97+i)}"')
        elif ptype == "bool":
            example_params.append("true")
        elif "int" in ptype:
            example_params.append(str(i + 1))
        elif "float" in ptype:
            example_params.append(f"{i+1}.0")
        else:
            example_params.append("nil // TODO: provide appropriate value")

    builder.write(f"result := {func_name}({', '.join(example_params)})")
    builder.write("fmt.Println(result)")
    builder.write("// Output:")

    # Generate expected output based on return type
    if return_type == "string":
        builder.write('// ""')
    elif return_type == "bool":
        builder.write("// true")
    elif "int" in return_type:
        builder.write("// 0")
    elif "float" in return_type:
        builder.write("// 0")
    else:
        builder.write("// <expected output>")

    builder.dedent()
    builder.write("}")
    builder.write("")

    # Add benchmark function
    builder.write(f"func Benchmark{func_name}(b *testing.B) {{")
    builder.indent()

    # Create benchmark parameters
    bench_params = []
    for i, ptype in enumerate(param_types):
        if ptype == "string":
            bench_params.append(f'"benchmark{i}"')
        elif ptype == "bool":
            bench_params.append("true")
        elif "int" in ptype:
            bench_params.append(str(i + 10))
        elif "float" in ptype:
            bench_params.append(f"{i+10}.5")
        else:
            bench_params.append("nil // TODO: provide appropriate value")

    # Reset timer in case setup is expensive
    builder.write("// Perform any expensive setup here")
    builder.write("b.ResetTimer()")

    # Benchmark loop
    builder.write("for i := 0; i < b.N; i++ {")
    builder.indent()
    builder.write(f"{func_name}({', '.join(bench_params)})")
    builder.dedent()
    builder.write("}")

    # Optionally add parallel benchmark
    builder.write("")
    builder.write("// Example of parallel benchmark")
    builder.write('b.Run("Parallel", func(b *testing.B) {')
    builder.indent()
    builder.write("b.ResetTimer()")
    builder.write("b.RunParallel(func(pb *testing.PB) {")
    builder.indent()
    builder.write("for pb.Next() {")
    builder.indent()
    builder.write(f"{func_name}({', '.join(bench_params)})")
    builder.dedent()
    builder.write("}")
    builder.dedent()
    builder.write("})")
    builder.dedent()
    builder.write("})")

    builder.dedent()
    builder.write("}")


def _expand_goswitch(builder, args):
    """Go switch. [var case1 case2...] - Create switch statement with cases."""
    # Parse arguments
    variable = "value"  # Default variable name
    cases = ["case1", "case2", "default"]  # Default cases

    if args:
        # First argument is the variable name
        variable = args[0]

        # Remaining arguments are cases
        if len(args) > 1:
            cases = args[1:]

    # Write switch statement
    builder.write(f"switch {variable} {{")
    builder.indent()

    # Add cases
    for case in cases:
        if case.lower() == "default":
            builder.write("default:")
        else:
            builder.write(f"case {case}:")

        builder.indent()
        if case.lower() == "default":
            builder.write(f"// Handle default case")
        else:
            builder.write(f"// Handle {case} case")
        builder.dedent()
        builder.write("")

    builder.dedent()
    builder.write("}")


def _expand_gointf(builder, args):
    """Go interface. [Name method1 method2...] - Define interface with empty methods."""
    # Default interface name and methods
    interface_name = "Reader"
    methods = ["Read"] if not args or len(args) <= 1 else args[1:]

    if args:
        # First argument is interface name
        interface_name = args[0]

    # Write interface definition
    builder.write(
        f"// {interface_name} defines methods for {interface_name.lower()} operations"
    )
    builder.write(f"type {interface_name} interface {{")
    builder.indent()

    # Add methods with empty signatures
    for method in methods:
        builder.write(f"{method}()")

    builder.dedent()
    builder.write("}")

    # Add implementation example if it's a simple interface (one method)
    if len(methods) == 1:
        struct_name = f"My{interface_name}"
        method = methods[0]

        builder.write("")
        builder.write(f"// {struct_name} implements the {interface_name} interface")
        builder.write(f"type {struct_name} struct {{")
        builder.indent()
        builder.write("// implementation fields")
        builder.dedent()
        builder.write("}")
        builder.write("")
        builder.write(f"// {method} implements {interface_name}.{method}")
        builder.write(f"func (m *{struct_name}) {method}() {{")
        builder.indent()
        builder.write("// implementation")
        builder.dedent()
        builder.write("}")


# Register all snippets
SNIPPETS = {
    "awkarray": _expand_awkarray,
    "awkbasic": _expand_awkbasic,
    "awkcsv": _expand_awkcsv,
    "awkfields": _expand_awkfields,
    "awkfile": _expand_awkfile,
    "awkformat": _expand_awkformat,
    "awkfunc": _expand_awkfunc,
    "awkgroup": _expand_awkgroup,
    "awkmath": _expand_awkmath,
    "awkregex": _expand_awkregex,
    "awksys": _expand_awksys,
    "gobasic": _expand_gobasic,
    "gocli": _expand_gocli,
    "goch": _expand_goch,
    "goerr": _expand_goerr,
    "gohttp": _expand_gohttp,
    "gointf": _expand_gointf,
    "gojson": _expand_gojson,
    "gostruct": _expand_gostruct,
    "goswitch": _expand_goswitch,
    "gotest": _expand_gotest,
    "gowg": _expand_gowg,
    "nfile": _expand_nfile,
    "nmeta": _expand_nmeta,
    "pyargs": _expand_pyargs,
    "pydir": _expand_pydir,
    "pyfilter": _expand_pyfilter,
    "shcase": _expand_shcase,
    "shdir": _expand_shdir,
    "shlog": _expand_shlog,
    "shopts": _expand_shopts,
}


if __name__ == "__main__":
    sys.exit(main() or 0)
