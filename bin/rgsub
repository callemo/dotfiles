#!/bin/sh
# usage: rgsub [-n] <regexp> <text>
# Recursive search and replace using regular expressions.
#
# Searches all text files in current directory tree (excluding .git/)
# and replaces matches. Uses extended regex (sed -E).
#
# Uses '@' as sed delimiter. If pattern or replacement contains '@',
# escape it as '\@'.
#
# Options:
#   -n    Dry run - show diffs of what would change
#
# Examples:
#   rgsub 'foo' 'bar'              # Replace foo with bar
#   rgsub 'old/path' 'new/path'    # Paths work (no escaping needed)
#   rgsub -n 'test' 'prod'         # Preview changes before applying

PATH=/bin:/usr/bin

usage() { sed -En '2,/^[^#]/ s/^# //p' "$0" >&2; }

while getopts :nh f
do
	case $f in
	h)  usage; exit 0;;
	n)  nflag=$f;;
	\?) usage; exit 2;;
	esac
done
shift $((OPTIND - 1))

case $# in
0|1)	usage; exit 2
esac

r="$1"
t="$2"

# Exit 1 if no matches (like grep)
grep -E -R -I -l "$r" . | grep -E -v '(^|/)\.git' >/dev/null || exit 1

# Platform-specific sed in-place syntax
case "$(uname)" in
OpenBSD)	set -- sed -E -e 's@'"$r"'@'"$t"'@g' -i ;;
*)		set -- sed -E -e 's@'"$r"'@'"$t"'@g' -i '' ;;
esac

# Dry-run mode: show diffs and exit
if [ -n "$nflag" ]
then
	tmp=/tmp/rgsub.$$
	trap 'rm -f $tmp' 0 1 2 15

	grep -E -R -I -l "$r" . | grep -E -v '(^|/)\.git' |
	while IFS= read -r file
	do
		sed -E -e 's@'"$r"'@'"$t"'@g' "$file" >$tmp
		if ! cmp -s "$file" $tmp
		then
			echo "file: $file"
			diff -u "$file" $tmp
			echo
		fi
	done
	exit
fi

# Normal mode: replace in-place
grep -E -R -I -l "$r" . |
	grep -E -v '(^|/)\.git' |
	xargs "$@"
